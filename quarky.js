var NodeStatus=(NodeStatus2=>{NodeStatus2[NodeStatus2["Clean"]=0]="Clean";NodeStatus2[NodeStatus2["Effect"]=1]="Effect";NodeStatus2[NodeStatus2["Dirty"]=2]="Dirty";NodeStatus2[NodeStatus2["Inactive"]=4]="Inactive";NodeStatus2[NodeStatus2["OnStack"]=8]="OnStack";NodeStatus2[NodeStatus2["Tracking"]=16]="Tracking";return NodeStatus2})(NodeStatus||{});let Epoch=0;let Scope=null;let Scheduled=false;const PendingLeaves=[];const PendingUpdates=[];const PendingSubs=[];let ScheduledCleanups=[];let ScheduledEffects=[];let DeactivationCandidates=[];let ExternalBatcher=work=>work();export function setBatchingBehavior(batcher){ExternalBatcher=batcher}const defaultEqual=(a,b)=>a===b;export function quark(initial,options){const q={value:initial,fn:options?.sub,equal:options?.equal??defaultEqual,status:0,lastChange:-1,lastVerified:Epoch,deps:null,obs:[],name:options?.name};const read=()=>readLeaf(q);read.set=value=>{writeLeaf(q,value);scheduleUpdates()};return read}export function derive(fn,options){const d={value:void 0,fn,equal:options?.equal??defaultEqual,status:4|16,lastChange:-1,lastVerified:-1,deps:[],obs:[],name:options?.name};const computed=()=>readNode(d);return computed}export function effect(arg1,arg2,arg3){if(typeof arg1==="function"){return simpleEffect(arg1,arg2)}else{return explicitEffect(arg1,arg2,arg3)}}function buildEffect(fn,status,name){return{value:void 0,fn,equal:null,status,lastChange:-1,lastVerified:-1,deps:[],obs:null,name}}function registerEffect(dispose,persistent){if(Scope&&!persistent){if(!Scope.effectHooks){Scope.effectHooks=[dispose]}else{Scope.effectHooks.push(dispose)}}}function simpleEffect(fn,options){const e=buildEffect(fn,1|16,options?.name);const dispose=()=>{cleanupEffect(e,true);scheduleUpdates()};registerEffect(dispose,options?.persistent);runComputation(e);return{dispose}}function explicitEffect(signals,computation,options){const fn=()=>{const input=new Array(signals.length);for(let i=0;i<signals.length;++i){input[i]=signals[i]()}computation(signals)};const e=buildEffect(fn,1|16,options?.name);const dispose=()=>{cleanupEffect(e,true);scheduleUpdates()};registerEffect(dispose,options?.persistent);if(options?.lazy){const s={accessed:e.deps,effectHooks:[],parent:Scope};Scope=s;for(let i=0;i<signals.length;++i){signals[i]()}for(let i=0;i<e.deps.length;++i){hook(e,e.deps[i])}Scope=s.parent}else{runComputation(e)}return{dispose}}export function observerEffect(computation){const node=buildEffect(computation,1);return{watch(computation2){const scope={accessed:[],effectHooks:null,parent:Scope};Scope=scope;const result=computation2();Scope=scope.parent;diffDeps(node,node.deps,scope.accessed);node.deps=scope.accessed;return result},dispose:()=>{cleanupEffect(node,true);scheduleUpdates()},node}}export function selectSignal(initial){const inner=quark(initial);const outer=()=>{const selected=inner();return selected?selected():void 0};outer.quark=inner;outer.select=selected=>inner.set(()=>selected);return outer}export function selectQuark(initial){return selectSignal(initial)}export function batch(work){const start=PendingLeaves.length;const prev=Scheduled;Scheduled=true;const result=work();processUpdates(start);if(!prev)processDeactivations();Scheduled=prev;return result}export function untrack(work){const saved=Scope;Scope=null;const result=work();Scope=saved;return result}function readLeaf(node){if(Scope){Scope.accessed.push(node)}return node.value}function readNode(node){if(Scope){Scope.accessed.push(node)}if(node.status!==0&&node.lastVerified<Epoch){if(node.status&8){handleError("Quarky detected a cycle!")}node.status|=8;runComputation(node);node.status^=8}return node.value}function scheduleUpdates(){if(!Scheduled){Scheduled=true;processUpdates(0);processDeactivations();Scheduled=false}}function processUpdates(start){ExternalBatcher(()=>{if(PendingLeaves.length===start&&ScheduledEffects.length===0)return;Epoch+=1;do{const leaves=PendingLeaves.splice(start);const updates=PendingUpdates.splice(start);for(let i=0;i<leaves.length;++i){const node=leaves[i];const u=updates[i];const prevValue=node.value;node.value=typeof u==="function"?u(node.value):u;if(node.equal(prevValue,node.value))continue;node.lastChange=Epoch;if(node.fn)PendingSubs.push(node);for(let j=node.obs.length-1;j>=0;--j){flagDirty(node.obs[j])}}let cleanups=ScheduledCleanups;let effects=ScheduledEffects;ScheduledCleanups=[];ScheduledEffects=[];for(let i=cleanups.length-1;i>=0;--i){cleanupEffect(cleanups[i],false)}for(let i=effects.length-1;i>=0;--i){const e=effects[i];if(e.status===0)continue;checkComputation(e)}}while(PendingLeaves.length>start||ScheduledEffects.length>0);if(start===0){const subs=new Set(PendingSubs);PendingSubs.length=0;for(const node of subs){node.fn(node.value)}}})}function processDeactivations(){let d=DeactivationCandidates.pop();while(d!==void 0){if(d.obs.length===0){for(let i=d.obs.length-1;i>=0;--i){unhook(d,d.deps[i])}d.status|=4}d=DeactivationCandidates.pop()}}function flagDirty(node){if(!(node.status&2)){node.status|=2;if(node.status&1){ScheduledEffects.push(node);if(node.equal)ScheduledCleanups.push(node)}else{for(let i=node.obs.length-1;i>=0;--i){flagDirty(node.obs[i])}}}}function checkComputation(node){let somethingChanged=false;let i=node.deps.length;while(!somethingChanged&&i-- >0){const d=node.deps[i];somethingChanged=d.lastChange===Epoch||d.status&2&&checkComputation(d)}node.status^=2;return somethingChanged&&runComputation(node)}function writeLeaf(node,update){PendingLeaves.push(node);PendingUpdates.push(update)}function activate(node){if(node.lastVerified<Epoch){throw new Error("Activation should always come after a read")}node.status&=~4;for(let i=node.deps.length-1;i>=0;--i){hook(node,node.deps[i])}}function runComputation(node){const scope={accessed:[],effectHooks:null,parent:Scope};const isDerivation=!(node.status&1);Scope=scope;const prev=node.value;node.value=node.fn();Scope=scope.parent;let somethingChanged;if(isDerivation){if(scope.effectHooks){console.error("Quarky detected the creation of an effect within a derivation. This is likely a memory leak!")}somethingChanged=!node.equal(prev,node.value);node.lastVerified=Epoch;if(somethingChanged)node.lastChange=Epoch}else{node.equal=scope.effectHooks?hooksRunner(scope.effectHooks):null;if(node.status&4){cleanupEffect(node,true);return true}somethingChanged=true}if(node.status&16){if(!(node.status&4)){diffDeps(node,node.deps,scope.accessed)}node.deps=scope.accessed}return somethingChanged}function diffDeps(node,before,after){if(depsAreEqual(before,after))return;const toRemove=new Set(before);const toAdd=new Set(after);for(const x of toRemove){if(!toAdd.delete(x)){unhook(node,x)}}for(const x of toAdd){hook(node,x)}}function depsAreEqual(before,after){if(before.length!==after.length)return false;for(let i=before.length-1;i>=0;--i){if(before[i]!==after[i])return false}return true}function hook(node,dep){dep.obs.push(node);if(dep.status&4){activate(dep)}}function unhook(node,dep){const lastObserver=dep.obs.pop();if(dep.deps&&dep.obs.length===0){DeactivationCandidates.push(dep)}if(lastObserver!==node){for(let i=dep.obs.length-1;i>=0;--i){if(dep.obs[i]===node){dep.obs[i]=lastObserver;break}}}}function hooksRunner(hooks){return deleted=>{for(let i=0;i<hooks.length;++i){hooks[i](deleted)}}}function cleanupEffect(node,deleted){if(deleted){node.status=node.status|4&~16;for(var i=node.deps.length;i-- >0;){unhook(node,node.deps[i])}node.deps=[]}if(node.equal){const toRun=node.equal;node.equal=null;toRun(deleted)}}export function onCleanup(hook2){if(!Scope){console.error("Quarky detected a use of onCleanup outside of any context");return}if(!Scope.effectHooks){Scope.effectHooks=[hook2]}else{Scope.effectHooks.push(hook2)}}function handleError(message){Scope=null;PendingLeaves.splice(0);PendingUpdates.splice(0);ScheduledEffects=[];ScheduledCleanups=[];Scheduled=false;throw new Error(message)}
